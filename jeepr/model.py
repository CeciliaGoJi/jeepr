# -*- coding: utf-8 -*-
"""
Defines earth model objects.

:copyright: 2017 Agile Geoscience
:license: Apache 2.0
"""
import re
import os
import operator

import numpy as np
from bs4 import BeautifulSoup
import vtk
from vtk.util.numpy_support import vtk_to_numpy

from . import utils
from bruges.transform import depth_to_time


class ModelError(Exception):
    """
    Generic error class.
    """
    pass


class Model(np.ndarray):
    """
    A fancy ndarray. Gives some utility functions, plotting, etc, for scans.
    """
    def __new__(cls, data, params):
        """
        I am just following the numpy guide for subclassing ndarray...
        """
        obj = np.asarray(data).view(cls).copy()

        params = params or {}

        for k, v in params.items():
            setattr(obj, k, v)

        return obj

    def __array_finalize__(self, obj):
        """
        I am just following the numpy guide for subclassing ndarray...
        """
        if obj is None:
            return

        if obj.size == 1:
            return float(obj)

        self.dt = getattr(obj, 'dt', 0)
        self.dz = getattr(obj, 'dz', 0)
        self.name = getattr(obj, 'name', '')

    def __copy__(self):
        cls = self.__class__
        result = cls.__new__(cls)
        result.__dict__.update(self.__dict__)
        return result

    @staticmethod
    def _get_vti_array(output, idx):
        flat = vtk_to_numpy(output.GetCellData().GetArray(idx))
        nx, ny, nz = np.array(output.GetDimensions()) - 1
        return np.flipud(flat.reshape((ny, nx, nz)))

    @staticmethod
    def _get_vti_gprmax_meta(fname, spacing):
        """
        Get the gprMax metadata from the XML in the VTI file.
        """
        with open(fname, 'rb') as f:
            data = str(f.read())
        try:
            gprmax = re.search(r'<gprMax>(.+?)</gprMax>', data).group(0)
        except AttributeError:
            raise ModelError('No gprMax section in VTI file.')

        soup = BeautifulSoup(gprmax, "xml")

        # Get materials.
        materials = [{'name': m['name'], 'value':int(m.contents[0])}
                     for m in soup.find_all("Material")
                     if '+' not in m['name']]

        meta = {"Materials": materials}

        # Get geometry.
        for e in ["PML", "Sources", "Receivers"]:
            meta[e] = {}
            meta[e]['name'] = soup.find(e)['name']
            meta[e]['value'] = int(soup.find(e).contents[0])

        pattern = re.compile(r'\(([0-9]+),([0-9]+),([0-9]+)\)')
        src = meta['Sources']['name']
        meta['Sources']['position'] = spacing * np.array([int(s)
                                                          for s
                                                          in pattern.search(src).groups()])
        meta['Sources']['type'] = src[:src.find('(')]
        rx = meta['Receivers']['name']
        meta['Receivers']['position'] = spacing * np.array([int(s)
                                                            for s
                                                            in pattern.search(rx).groups()])
        return meta

    @classmethod
    def from_vti(cls, fname, idx=0):
        """
        Get data and metadata from a VTK file.

        Assumes gprMax 'material' array has index 0.
        """
        reader = vtk.vtkXMLImageDataReader()
        reader.SetFileName(fname)
        reader.Update()

        output = reader.GetOutput()
        dx_dy_dz = reader.GetOutput().GetSpacing()

        arr = cls._get_vti_array(output, 0)
        pml = (cls._get_vti_array(output, 1) == 1).astype(int)
        npml = np.where(pml[:, pml.shape[1]//2] == 0)[0][0]

        # Squeeze out the last dim if it's really a 2D model.
        if arr.shape[-1] == 1:
            arr = arr.squeeze()

        params = {'dx_dy_dz': dx_dy_dz,
                  'dx': dx_dy_dz[1],
                  'dz': dx_dy_dz[2],
                  'npml': npml,
                  'domain': 'depth',
                  }

        return cls(arr, params)

    @classmethod
    def from_gprMax_vti(cls, fname):
        """
        Constructor for VTK VTI files, as generated by gprMax. These have
        some special gprMax-specific metadata.

        Args:
            fname (str): a gprMax-generated VTI file.

        Returns:
            model. The model object.
        """
        model = cls.from_vti(fname)
        params = model.__dict__

        meta = cls._get_vti_gprmax_meta(fname, model.dx_dy_dz)
        params['rx'] = meta['Receivers']
        params['tx'] = meta['Sources']
        params['materials'] = meta['Materials']

        return cls(model, params)

    @classmethod
    def from_gprMax(cls, fname):
        """
        Constructor for gprMax .in files, as generated by gprMax. These have
        some special gprMax-specific metadata.

        Args:
            fname (str): a gprMax-generated .in file.

        Returns:
            model. The model object.
        """
        geom, = utils.get_lines(fname, 'geometry_view')
        path = os.path.split(fname)[0]
        vti = os.path.join(path, geom.split()[-2]) + "1.vti"
        model = cls.from_gprMax_vti(vti)
        params = model.__dict__

        # Get metadata.
        meta = cls._get_vti_gprmax_meta(vti, model.dx_dy_dz)
        params['rx'] = meta['Receivers']
        params['tx'] = meta['Sources']
        params['materials'] = meta['Materials']

        # Get tx/rx steps.
        tx_steps, = utils.get_lines(fname, 'src_steps')
        rx_steps, = utils.get_lines(fname, 'rx_steps')
        params['tx_steps'] = [float(i) for i in tx_steps.split()]
        params['rx_steps'] = [float(i) for i in rx_steps.split()]

        # Get material properties.
        material_perms = utils.get_gprMax_materials(fname)
        mapping = {m['name']: m['value'] for m in params['materials']}
        material_list = [i[0] for i in sorted(mapping.items(), key=operator.itemgetter(1))]
        perms = np.array([material_perms[i] for i in material_list])
        #earth_model = perms[model]
        params['permittivities'] = perms

        return cls(model, params)

    @property
    def x(self):
        return utils.srange(0, self.dx, self.nx)

    @property
    def nx(self):
        return self.shape[1]

    @property
    def basis(self):
        if self.domain == 'depth':
            return utils.srange(0, self.dz, self.shape[0])
        else:
            return utils.srange(0, self.dt, self.shape[0])

    @property
    def extent(self):
        if self.domain == 'depth':
            mult = 1
        else:
            mult = 1e9
        return [self.x[0], self.x[-1], mult*self.basis[-1], mult*self.basis[0]]

    @property
    def velocity(self):
        return utils.c / np.sqrt(self.permittivities[self])

    def to_time(self, v=None, dt=1e-12):
        params = self.__dict__.copy()
        if v is None:
            v = self.velocity
        arr = depth_to_time(self, v, dz=self.dz, dt=dt)
        basis = utils.srange(0, dt, arr.shape[0])
        params['domain'] = 'time'
        params['dz'] = 0
        params['dt'] = dt
        return Model(arr, params), basis
